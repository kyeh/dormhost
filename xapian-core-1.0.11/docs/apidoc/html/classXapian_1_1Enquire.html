<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: xapian-core: Xapian::Enquire Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceXapian.html">Xapian</a>::<a class="el" href="classXapian_1_1Enquire.html">Enquire</a></div>
<h1>Xapian::Enquire Class Reference</h1><!-- doxytag: class="Xapian::Enquire" -->This class provides an interface to the information retrieval system for the purpose of searching.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="enquire_8h-source.html">enquire.h</a>&gt;</code>
<p>
<a href="classXapian_1_1Enquire-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>docid_order</b> { <b>ASCENDING</b> =  1, 
<b>DESCENDING</b> =  0, 
<b>DONT_CARE</b> =  2
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#62119dce412aeab4cc9c865f5b308377">Enquire</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying is allowed (and is cheap).  <a href="#62119dce412aeab4cc9c865f5b308377"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#b02cc3f86ee94f792a1dba00f54b0e5f">operator=</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment is allowed (and is cheap).  <a href="#b02cc3f86ee94f792a1dba00f54b0e5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#7b33dfdd2ae024beaa86aa8a8d49a2da">Enquire</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;database, <a class="el" href="classXapian_1_1ErrorHandler.html">ErrorHandler</a> *errorhandler_=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object.  <a href="#7b33dfdd2ae024beaa86aa8a8d49a2da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#2bd9b0db9c9b062d035d0d17bf778554">~Enquire</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object.  <a href="#2bd9b0db9c9b062d035d0d17bf778554"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#8c154816b78c5a1e6b6c68db9b71fd49">set_query</a> (const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;query, <a class="el" href="namespaceXapian.html#3261017447607738e49eae6a2a4f5eec">Xapian::termcount</a> qlen=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the query to run.  <a href="#8c154816b78c5a1e6b6c68db9b71fd49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#7d43e83e60e074d7ac2372ca12fe6c77">get_query</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the query which has been set.  <a href="#7d43e83e60e074d7ac2372ca12fe6c77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#fc56192bd06d87100781d37246e13752">set_weighting_scheme</a> (const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;weight_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the weighting scheme to use for queries.  <a href="#fc56192bd06d87100781d37246e13752"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#f32055d3a4da31da994d97171f45d699">set_collapse_key</a> (<a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a> collapse_key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the collapse key to use for queries.  <a href="#f32055d3a4da31da994d97171f45d699"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#0adc341c01f5249d263cdccfbae800a9">set_docid_order</a> (docid_order order)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>.  <a href="#0adc341c01f5249d263cdccfbae800a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#99fc7e222b5dd192df464c47e87d85ba">set_cutoff</a> (<a class="el" href="namespaceXapian.html#86533cd9df01e80d23d758d74c7e1150">Xapian::percent</a> percent_cutoff, <a class="el" href="namespaceXapian.html#ee1bece7207c349621963d7f584dd98b">Xapian::weight</a> weight_cutoff=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the percentage and/or weight cutoffs.  <a href="#99fc7e222b5dd192df464c47e87d85ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#67ae9429d1a2abf43f1d3adbc2133f51">set_sort_by_relevance</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by relevance only.  <a href="#67ae9429d1a2abf43f1d3adbc2133f51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#8b452a1301039d72627edaa4a81d6eaa">set_sort_by_value</a> (<a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a> sort_key, bool reverse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by value only.  <a href="#8b452a1301039d72627edaa4a81d6eaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ab723e935b7e7706898a37f416b4b5ec">set_sort_by_key</a> (<a class="el" href="classXapian_1_1Sorter.html">Xapian::Sorter</a> *sorter, bool reverse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by key generated from values only.  <a href="#ab723e935b7e7706898a37f416b4b5ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#20b077282c1980461c437208512449ce">set_sort_by_value_then_relevance</a> (<a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a> sort_key, bool reverse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by value, then by relevance for documents with the same value.  <a href="#20b077282c1980461c437208512449ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#86333b3204ca20d001b2a17277935f0f">set_sort_by_key_then_relevance</a> (<a class="el" href="classXapian_1_1Sorter.html">Xapian::Sorter</a> *sorter, bool reverse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by keys generated from values, then by relevance for documents with identical keys.  <a href="#86333b3204ca20d001b2a17277935f0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#623c139ed751fabb0fb51a100d8dd9e7">set_sort_by_relevance_then_value</a> (<a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a> sort_key, bool reverse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by relevance then value.  <a href="#623c139ed751fabb0fb51a100d8dd9e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#75f885c825e642bd44c45ddf9e0d5868">set_sort_by_relevance_then_key</a> (<a class="el" href="classXapian_1_1Sorter.html">Xapian::Sorter</a> *sorter, bool reverse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by relevance, then by keys generated from values.  <a href="#75f885c825e642bd44c45ddf9e0d5868"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#b87e1a1d4302cf636edd04b848eabcbc">get_mset</a> (<a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> checkatleast=0, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset=0, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#b87e1a1d4302cf636edd04b848eabcbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90292b73d9283438f8b99a1522474738"></a><!-- doxytag: member="Xapian::Enquire::get_mset" ref="90292b73d9283438f8b99a1522474738" args="(Xapian::doccount first, Xapian::doccount maxitems, Xapian::doccount checkatleast, const RSet *omrset, const MatchDecider *mdecider, const MatchDecider *matchspy) const" -->
<a class="el" href="classXapian_1_1MSet.html">MSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_mset</b> (<a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> checkatleast, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *matchspy) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eeb0db06f63532cc09a0a1e405045f8c"></a><!-- doxytag: member="Xapian::Enquire::get_mset" ref="eeb0db06f63532cc09a0a1e405045f8c" args="(Xapian::doccount first, Xapian::doccount maxitems, const RSet *omrset, const MatchDecider *mdecider=0) const" -->
<a class="el" href="classXapian_1_1MSet.html">MSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_mset</b> (<a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#96ce4fcc49cc57adeebfb56aa7cac344">XAPIAN_DEPRECATED</a> (static const int include_query_terms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated in <a class="el" href="namespaceXapian.html" title="The Xapian library lives in the Xapian namespace.">Xapian</a> 1.0.0, use INCLUDE_QUERY_TERMS instead.  <a href="#96ce4fcc49cc57adeebfb56aa7cac344"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#5d745ce81ab73e200efe57026bc7e340">XAPIAN_DEPRECATED</a> (static const int use_exact_termfreq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated in <a class="el" href="namespaceXapian.html" title="The Xapian library lives in the Xapian namespace.">Xapian</a> 1.0.0, use USE_EXACT_TERMFREQ instead.  <a href="#5d745ce81ab73e200efe57026bc7e340"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#274b654da131960486acdaa2f095ea27">get_eset</a> (<a class="el" href="namespaceXapian.html#3261017447607738e49eae6a2a4f5eec">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, int flags=0, double k=1.0, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider=0) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#274b654da131960486acdaa2f095ea27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#2b703053e9004951e9bd9e280321973b">get_eset</a> (<a class="el" href="namespaceXapian.html#3261017447607738e49eae6a2a4f5eec">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#2b703053e9004951e9bd9e280321973b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#373073713b1088df8daf2c41a668e6f6">get_matching_terms_begin</a> (<a class="el" href="namespaceXapian.html#d8d873ad5830cff0b4bbd89d7da45d15">Xapian::docid</a> did) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get terms which match a given document, by document id.  <a href="#373073713b1088df8daf2c41a668e6f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#18942dc1833a9e06bc0106cbe4c2a304">get_matching_terms_end</a> (<a class="el" href="namespaceXapian.html#d8d873ad5830cff0b4bbd89d7da45d15">Xapian::docid</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#373073713b1088df8daf2c41a668e6f6" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a>.  <a href="#18942dc1833a9e06bc0106cbe4c2a304"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#e8516b64dfe58217efb1111294a9eb8b">get_matching_terms_begin</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;it) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get terms which match a given document, by match set item.  <a href="#e8516b64dfe58217efb1111294a9eb8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#409f4478bab5d7566e416505a9f03b49">get_matching_terms_end</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#373073713b1088df8daf2c41a668e6f6" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a>.  <a href="#409f4478bab5d7566e416505a9f03b49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#8871ad1923b99754ead79d97bd35179d">XAPIAN_DEPRECATED</a> (void register_match_decider(const std::string &amp;name, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=NULL))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1MatchDecider.html" title="Base class for matcher decision functor.">MatchDecider</a>.  <a href="#8871ad1923b99754ead79d97bd35179d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#c26f97b7895e50906a338e014e1b5fa9">get_description</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing this object.  <a href="#c26f97b7895e50906a338e014e1b5fa9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f70c0e98918cc9aa71e7baa787bc8624"></a><!-- doxytag: member="Xapian::Enquire::internal" ref="f70c0e98918cc9aa71e7baa787bc8624" args="" -->
Xapian::Internal::RefCntPtr&lt;<br>
 Internal &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal</b></td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ed6f9f6902ffe879b27985c17546356"></a><!-- doxytag: member="Xapian::Enquire::INCLUDE_QUERY_TERMS" ref="4ed6f9f6902ffe879b27985c17546356" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>INCLUDE_QUERY_TERMS</b> = 1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00cfcdcdace0146b455b911e2059abe0"></a><!-- doxytag: member="Xapian::Enquire::USE_EXACT_TERMFREQ" ref="00cfcdcdace0146b455b911e2059abe0" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>USE_EXACT_TERMFREQ</b> = 2</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides an interface to the information retrieval system for the purpose of searching. 
<p>
Databases are usually opened lazily, so exceptions may not be thrown where you would expect them to be. You should catch Xapian::Error exceptions when calling any method in <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a>.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>will be thrown if an invalid argument is supplied, for example, an unknown database type. </td></tr>
  </table>
</dl>

<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="62119dce412aeab4cc9c865f5b308377"></a><!-- doxytag: member="Xapian::Enquire::Enquire" ref="62119dce412aeab4cc9c865f5b308377" args="(const Enquire &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::Enquire           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copying is allowed (and is cheap). 
<p>

</div>
</div><p>
<a class="anchor" name="7b33dfdd2ae024beaa86aa8a8d49a2da"></a><!-- doxytag: member="Xapian::Enquire::Enquire" ref="7b33dfdd2ae024beaa86aa8a8d49a2da" args="(const Database &amp;database, ErrorHandler *errorhandler_=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::Enquire           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXapian_1_1ErrorHandler.html">ErrorHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>errorhandler_</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object. 
<p>
This specification cannot be changed once the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> is opened: you must create a new <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object to access a different database, or set of databases.<p>
The database supplied must have been initialised (ie, must not be the result of calling the Database::Database() constructor). If you need to handle a situation where you have no index gracefully, a database created with InMemory::open() can be passed here, which represents a completely empty database.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>Specification of the database or databases to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorhandler_</em>&nbsp;</td><td>A pointer to the error handler to use. Ownership of the object pointed to is not assumed by the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object - the user should delete the <a class="el" href="classXapian_1_1ErrorHandler.html" title="Decide if a Xapian::Error exception should be ignored.">Xapian::ErrorHandler</a> object after the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object is deleted. To use no error handler, this parameter should be 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>will be thrown if an initialised <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object is supplied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2bd9b0db9c9b062d035d0d17bf778554"></a><!-- doxytag: member="Xapian::Enquire::~Enquire" ref="2bd9b0db9c9b062d035d0d17bf778554" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::~Enquire           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b02cc3f86ee94f792a1dba00f54b0e5f"></a><!-- doxytag: member="Xapian::Enquire::operator=" ref="b02cc3f86ee94f792a1dba00f54b0e5f" args="(const Enquire &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment is allowed (and is cheap). 
<p>

</div>
</div><p>
<a class="anchor" name="8c154816b78c5a1e6b6c68db9b71fd49"></a><!-- doxytag: member="Xapian::Enquire::set_query" ref="8c154816b78c5a1e6b6c68db9b71fd49" args="(const Xapian::Query &amp;query, Xapian::termcount qlen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_query           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#3261017447607738e49eae6a2a4f5eec">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>qlen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the query to run. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query</em>&nbsp;</td><td>the new query to run. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qlen</em>&nbsp;</td><td>the query length to use in weight calculations - by default the sum of the wqf of all terms is used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7d43e83e60e074d7ac2372ca12fe6c77"></a><!-- doxytag: member="Xapian::Enquire::get_query" ref="7d43e83e60e074d7ac2372ca12fe6c77" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&amp; Xapian::Enquire::get_query           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the query which has been set. 
<p>
This is only valid after <a class="el" href="classXapian_1_1Enquire.html#8c154816b78c5a1e6b6c68db9b71fd49" title="Set the query to run.">set_query()</a> has been called.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>will be thrown if query has not yet been set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc56192bd06d87100781d37246e13752"></a><!-- doxytag: member="Xapian::Enquire::set_weighting_scheme" ref="fc56192bd06d87100781d37246e13752" args="(const Weight &amp;weight_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_weighting_scheme           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>weight_</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the weighting scheme to use for queries. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight_</em>&nbsp;</td><td>the new weighting scheme. If no weighting scheme is specified, the default is BM25 with the default parameters. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f32055d3a4da31da994d97171f45d699"></a><!-- doxytag: member="Xapian::Enquire::set_collapse_key" ref="f32055d3a4da31da994d97171f45d699" args="(Xapian::valueno collapse_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_collapse_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>collapse_key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the collapse key to use for queries. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collapse_key</em>&nbsp;</td><td>value number to collapse on - at most one <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a> entry with each particular value will be returned.</td></tr>
  </table>
</dl>
The entry returned will be the best entry with that particular value (highest weight or highest sorting key).<p>
An example use might be to create a value for each document containing an MD5 hash of the document contents. Then duplicate documents from different sources can be eliminated at search time (it's better to eliminate duplicates at index time, but this may not be always be possible - for example the search may be over more than one <a class="el" href="namespaceXapian.html" title="The Xapian library lives in the Xapian namespace.">Xapian</a> database).<p>
Another use is to group matches in a particular category (e.g. you might collapse a mailing list search on the Subject: so that there's only one result per discussion thread). In this case you can use get_collapse_count() to give the user some idea how many other results there are. And if you index the Subject: as a boolean term as well as putting it in a value, you can offer a link to a non-collapsed search restricted to that thread using a boolean filter.<p>
(default is <a class="el" href="namespaceXapian.html#0a100329c2c04d4683a77615b7ed6e8e" title="Reserved value to indicate "no valueno".">Xapian::BAD_VALUENO</a> which means no collapsing). 
</div>
</div><p>
<a class="anchor" name="0adc341c01f5249d263cdccfbae800a9"></a><!-- doxytag: member="Xapian::Enquire::set_docid_order" ref="0adc341c01f5249d263cdccfbae800a9" args="(docid_order order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_docid_order           </td>
          <td>(</td>
          <td class="paramtype">docid_order&nbsp;</td>
          <td class="paramname"> <em>order</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. 
<p>
This order only has an effect on documents which would otherwise have equal rank. For a weighted probabilistic match with no sort value, this means documents with equal weight. For a boolean match, with no sort value, this means all documents. And if a sort value is used, this means documents with equal sort value (and also equal weight if ordering on relevance after the sort).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>This can be:<ul>
<li>Xapian::Enquire::ASCENDING docids sort in ascending order (default)</li><li>Xapian::Enquire::DESCENDING docids sort in descending order</li><li>Xapian::Enquire::DONT_CARE docids sort in whatever order is most efficient for the backend</li></ul>
</td></tr>
  </table>
</dl>
Note: If you add documents in strict date order, then a boolean search - i.e. set_weighting_scheme(Xapian::BoolWeight()) - with set_docid_order(Xapian::Enquire::DESCENDING) is a very efficient way to perform "sort by date, newest first". 
</div>
</div><p>
<a class="anchor" name="99fc7e222b5dd192df464c47e87d85ba"></a><!-- doxytag: member="Xapian::Enquire::set_cutoff" ref="99fc7e222b5dd192df464c47e87d85ba" args="(Xapian::percent percent_cutoff, Xapian::weight weight_cutoff=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_cutoff           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#86533cd9df01e80d23d758d74c7e1150">Xapian::percent</a>&nbsp;</td>
          <td class="paramname"> <em>percent_cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#ee1bece7207c349621963d7f584dd98b">Xapian::weight</a>&nbsp;</td>
          <td class="paramname"> <em>weight_cutoff</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the percentage and/or weight cutoffs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>percent_cutoff</em>&nbsp;</td><td>Minimum percentage score for returned documents. If a document has a lower percentage score than this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. If your intention is to return only matches which contain all the terms in the query, then it's more efficient to use <a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f6219fe995e29748a4324108b2f859f8607" title="Return iff both subqueries are satisfied.">Xapian::Query::OP_AND</a> instead of <a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f6282e33801d897b974065a281e1c34e39d" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a> in the query than to use set_cutoff(100). (default 0 =&gt; no percentage cut-off). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight_cutoff</em>&nbsp;</td><td>Minimum weight for a document to be returned. If a document has a lower score that this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. It is usually only possible to choose an appropriate weight for cutoff based on the results of a previous run of the same query; this is thus mainly useful for alerting operations. The other potential use is with a user specified weighting scheme. (default 0 =&gt; no weight cut-off). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="67ae9429d1a2abf43f1d3adbc2133f51"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_relevance" ref="67ae9429d1a2abf43f1d3adbc2133f51" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by relevance only. 
<p>
This is the default. 
</div>
</div><p>
<a class="anchor" name="8b452a1301039d72627edaa4a81d6eaa"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_value" ref="8b452a1301039d72627edaa4a81d6eaa" args="(Xapian::valueno sort_key, bool reverse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by value only. 
<p>
NB sorting of values uses a string comparison, so you'll need to store numbers padded with leading zeros or spaces, or with the number of digits prepended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sort_key</em>&nbsp;</td><td>value number to sort on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. (default true, but this default is confusing and deprecated in 1.1.0, so we recommend specifying this parameter explicitly). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab723e935b7e7706898a37f416b4b5ec"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_key" ref="ab723e935b7e7706898a37f416b4b5ec" args="(Xapian::Sorter *sorter, bool reverse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Sorter.html">Xapian::Sorter</a> *&nbsp;</td>
          <td class="paramname"> <em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by key generated from values only. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sorter</em>&nbsp;</td><td>The functor to use for generating keys.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. (default true, but this default is confusing and deprecated in 1.1.0, so we recommend specifying this parameter explicitly). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20b077282c1980461c437208512449ce"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_value_then_relevance" ref="20b077282c1980461c437208512449ce" args="(Xapian::valueno sort_key, bool reverse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value_then_relevance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by value, then by relevance for documents with the same value. 
<p>
NB sorting of values uses a string comparison, so you'll need to store numbers padded with leading zeros or spaces, or with the number of digits prepended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sort_key</em>&nbsp;</td><td>value number to sort on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. (default true, but this default is confusing and deprecated in 1.1.0, so we recommend specifying this parameter explicitly). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="86333b3204ca20d001b2a17277935f0f"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_key_then_relevance" ref="86333b3204ca20d001b2a17277935f0f" args="(Xapian::Sorter *sorter, bool reverse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key_then_relevance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Sorter.html">Xapian::Sorter</a> *&nbsp;</td>
          <td class="paramname"> <em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by keys generated from values, then by relevance for documents with identical keys. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sorter</em>&nbsp;</td><td>The functor to use for generating keys.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. (default true, but this default is confusing and deprecated in 1.1.0, so we recommend specifying this parameter explicitly). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="623c139ed751fabb0fb51a100d8dd9e7"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_relevance_then_value" ref="623c139ed751fabb0fb51a100d8dd9e7" args="(Xapian::valueno sort_key, bool reverse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#e163c06958fa73cfac44a38c3eea5c10">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by relevance then value. 
<p>
NB sorting of values uses a string comparison, so you'll need to store numbers padded with leading zeros or spaces, or with the number of digits prepended.<p>
Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#67ae9429d1a2abf43f1d3adbc2133f51" title="Set the sorting to be by relevance only.">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sort_key</em>&nbsp;</td><td>value number to sort on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. (default true, but this default is confusing and deprecated in 1.1.0, so we recommend specifying this parameter explicitly). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="75f885c825e642bd44c45ddf9e0d5868"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_relevance_then_key" ref="75f885c825e642bd44c45ddf9e0d5868" args="(Xapian::Sorter *sorter, bool reverse=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Sorter.html">Xapian::Sorter</a> *&nbsp;</td>
          <td class="paramname"> <em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by relevance, then by keys generated from values. 
<p>
Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#67ae9429d1a2abf43f1d3adbc2133f51" title="Set the sorting to be by relevance only.">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sorter</em>&nbsp;</td><td>The functor to use for generating keys.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. (default true, but this default is confusing and deprecated in 1.1.0, so we recommend specifying this parameter explicitly). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b87e1a1d4302cf636edd04b848eabcbc"></a><!-- doxytag: member="Xapian::Enquire::get_mset" ref="b87e1a1d4302cf636edd04b848eabcbc" args="(Xapian::doccount first, Xapian::doccount maxitems, Xapian::doccount checkatleast=0, const RSet *omrset=0, const MatchDecider *mdecider=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#44d2c93635cd10ee7d06a8d776f032cf">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>checkatleast</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&nbsp;</td>
          <td class="paramname"> <em>omrset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>mdecider</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get (a portion of) the match set for the current query. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object (though if you are doing this so you can filter results, you are likely to get better performance by using Xapian's match-time filtering features instead). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>checkatleast</em>&nbsp;</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchspy</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="96ce4fcc49cc57adeebfb56aa7cac344"></a><!-- doxytag: member="Xapian::Enquire::XAPIAN_DEPRECATED" ref="96ce4fcc49cc57adeebfb56aa7cac344" args="(static const int include_query_terms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::XAPIAN_DEPRECATED           </td>
          <td>(</td>
          <td class="paramtype">static const int&nbsp;</td>
          <td class="paramname"> <em>include_query_terms</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated in <a class="el" href="namespaceXapian.html" title="The Xapian library lives in the Xapian namespace.">Xapian</a> 1.0.0, use INCLUDE_QUERY_TERMS instead. 
<p>

</div>
</div><p>
<a class="anchor" name="5d745ce81ab73e200efe57026bc7e340"></a><!-- doxytag: member="Xapian::Enquire::XAPIAN_DEPRECATED" ref="5d745ce81ab73e200efe57026bc7e340" args="(static const int use_exact_termfreq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::XAPIAN_DEPRECATED           </td>
          <td>(</td>
          <td class="paramtype">static const int&nbsp;</td>
          <td class="paramname"> <em>use_exact_termfreq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated in <a class="el" href="namespaceXapian.html" title="The Xapian library lives in the Xapian namespace.">Xapian</a> 1.0.0, use USE_EXACT_TERMFREQ instead. 
<p>

</div>
</div><p>
<a class="anchor" name="274b654da131960486acdaa2f095ea27"></a><!-- doxytag: member="Xapian::Enquire::get_eset" ref="274b654da131960486acdaa2f095ea27" args="(Xapian::termcount maxitems, const RSet &amp;omrset, int flags=0, double k=1.0, const Xapian::ExpandDecider *edecider=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#3261017447607738e49eae6a2a4f5eec">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>k</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>edecider</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the expand set for the given rset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li><li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>the parameter k in the query expansion algorithm (default is 1.0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a> object containing the results of the expand.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b703053e9004951e9bd9e280321973b"></a><!-- doxytag: member="Xapian::Enquire::get_eset" ref="2b703053e9004951e9bd9e280321973b" args="(Xapian::termcount maxitems, const RSet &amp;omrset, const Xapian::ExpandDecider *edecider) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#3261017447607738e49eae6a2a4f5eec">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>edecider</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the expand set for the given rset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a> object containing the results of the expand.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="373073713b1088df8daf2c41a668e6f6"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_begin" ref="373073713b1088df8daf2c41a668e6f6" args="(Xapian::docid did) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#d8d873ad5830cff0b4bbd89d7da45d15">Xapian::docid</a>&nbsp;</td>
          <td class="paramname"> <em>did</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get terms which match a given document, by document id. 
<p>
This method returns the terms in the current query which match the given document.<p>
It is possible for the document to have been removed from the database between the time it is returned in an <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>, and the time that this call is made. If possible, you should specify an <a class="el" href="classXapian_1_1MSetIterator.html" title="An iterator pointing to items in an MSet.">MSetIterator</a> instead of a <a class="el" href="namespaceXapian.html#d8d873ad5830cff0b4bbd89d7da45d15" title="A unique identifier for a document.">Xapian::docid</a>, since this will enable database backends with suitable support to prevent this occurring.<p>
Note that a query does not need to have been run in order to make this call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>did</em>&nbsp;</td><td>The document id for which to retrieve the matching terms.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>See class documentation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Xapian::DocNotFoundError</em>&nbsp;</td><td>The document specified could not be found in the database. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="18942dc1833a9e06bc0106cbe4c2a304"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_end" ref="18942dc1833a9e06bc0106cbe4c2a304" args="(Xapian::docid) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_end           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#d8d873ad5830cff0b4bbd89d7da45d15">Xapian::docid</a>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#373073713b1088df8daf2c41a668e6f6" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="e8516b64dfe58217efb1111294a9eb8b"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_begin" ref="e8516b64dfe58217efb1111294a9eb8b" args="(const MSetIterator &amp;it) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get terms which match a given document, by match set item. 
<p>
This method returns the terms in the current query which match the given document.<p>
If the underlying database has suitable support, using this call (rather than passing a <a class="el" href="namespaceXapian.html#d8d873ad5830cff0b4bbd89d7da45d15" title="A unique identifier for a document.">Xapian::docid</a>) will enable the system to ensure that the correct data is returned, and that the document has not been deleted or changed since the query was performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The iterator for which to retrieve the matching terms.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Xapian::InvalidArgumentError</em>&nbsp;</td><td>See class documentation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Xapian::DocNotFoundError</em>&nbsp;</td><td>The document specified could not be found in the database. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="409f4478bab5d7566e416505a9f03b49"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_end" ref="409f4478bab5d7566e416505a9f03b49" args="(const MSetIterator &amp;) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_end           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#373073713b1088df8daf2c41a668e6f6" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="8871ad1923b99754ead79d97bd35179d"></a><!-- doxytag: member="Xapian::Enquire::XAPIAN_DEPRECATED" ref="8871ad1923b99754ead79d97bd35179d" args="(void register_match_decider(const std::string &amp;name, const MatchDecider *mdecider=NULL))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::XAPIAN_DEPRECATED           </td>
          <td>(</td>
          <td class="paramtype">void &nbsp;</td>
          <td class="paramname"> <em>register_match_decider</em>(const std::string &amp;name, const MatchDecider *mdecider=NULL)          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a <a class="el" href="classXapian_1_1MatchDecider.html" title="Base class for matcher decision functor.">MatchDecider</a>. 
<p>
This is used to associate a name with a matchdecider.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This method is deprecated. It was added long ago with the intention that it would allow the remote backend to support use of <a class="el" href="classXapian_1_1MatchDecider.html" title="Base class for matcher decision functor.">MatchDecider</a> objects, but there's a better approach.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to register this matchdecider as. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdecider</em>&nbsp;</td><td>The matchdecider. If omitted, then remove any matchdecider registered with this name. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c26f97b7895e50906a338e014e1b5fa9"></a><!-- doxytag: member="Xapian::Enquire::get_description" ref="c26f97b7895e50906a338e014e1b5fa9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::Enquire::get_description           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string describing this object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>include/xapian/<a class="el" href="enquire_8h-source.html">enquire.h</a></ul>
<hr>
<address><small>
Documentation for Xapian (version 1.0.11).<br>
Generated on 15 Mar 2009 by
<a href="http://www.doxygen.org/">Doxygen 1.5.2</a>.
</small></address>
</body>
</html>
