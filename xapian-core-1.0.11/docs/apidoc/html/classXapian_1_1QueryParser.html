<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: xapian-core: Xapian::QueryParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceXapian.html">Xapian</a>::<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a></div>
<h1>Xapian::QueryParser Class Reference</h1><!-- doxytag: class="Xapian::QueryParser" -->Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="queryparser_8h-source.html">queryparser.h</a>&gt;</code>
<p>
<a href="classXapian_1_1QueryParser-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e4">feature_flag</a> { <br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e459f19295c3150ad8511b7e8457fef73b">FLAG_BOOLEAN</a> =  1, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e49e741302592d96033bd31bcdae63a044">FLAG_PHRASE</a> =  2, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e4b20af685e8582c7a13a51aaf313aa326">FLAG_LOVEHATE</a> =  4, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e442e07cee2f367b773187cc4fe73ab7fc">FLAG_BOOLEAN_ANY_CASE</a> =  8, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e4e903f7f74be4432120446cca7fd22396">FLAG_WILDCARD</a> =  16, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e484cf1fd3c0289633db308d687bed8cf2">FLAG_PURE_NOT</a> =  32, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e439a9ed1d92a1a1bd5bcd66e721918661">FLAG_PARTIAL</a> =  64, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e47bb7341fb84b787be2572e3379997b33">FLAG_SPELLING_CORRECTION</a> =  128, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e400722e941bf07543aa9e7374fb9213ec">FLAG_SYNONYM</a> =  256, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e40a17e810397100d7bcca858ccc0d7f08">FLAG_AUTO_SYNONYMS</a> =  512, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e4abb8af23bce169ef29b66f33b4e38acc">FLAG_AUTO_MULTIWORD_SYNONYMS</a> =  1024 | FLAG_AUTO_SYNONYMS, 
<a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e48d441f43bfaf080cabccc437726e0bb0">FLAG_DEFAULT</a> =  FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum of feature flags.  <a href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e4">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>stem_strategy</b> { <b>STEM_NONE</b>, 
<b>STEM_SOME</b>, 
<b>STEM_ALL</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#b5bd2f39ee1d3ed110876ca4777e74f0">QueryParser</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#b5bd2f39ee1d3ed110876ca4777e74f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#20b23a728f0eb8532af052628c6c037a">operator=</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#20b23a728f0eb8532af052628c6c037a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#839b417cc7fd1068a19f2e346945d613">QueryParser</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#839b417cc7fd1068a19f2e346945d613"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#0a651bc6a41a13c1a7ef0fccbb0b0865">~QueryParser</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#0a651bc6a41a13c1a7ef0fccbb0b0865"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#d0529560adaf114192aa2d4a8055ddc1">set_stemmer</a> (const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;stemmer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stemmer.  <a href="#d0529560adaf114192aa2d4a8055ddc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#4829638f027160d317e35740c3ae2b31">set_stemming_strategy</a> (stem_strategy strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stemming strategy.  <a href="#4829638f027160d317e35740c3ae2b31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#fa2cd85108b18ee5f01c43abb6833f67">set_stopper</a> (const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *stop=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stopper.  <a href="#fa2cd85108b18ee5f01c43abb6833f67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#7c7492787fcdd3e9cfcae8325269e6bd">set_default_op</a> (<a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f62">Query::op</a> default_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default boolean operator.  <a href="#7c7492787fcdd3e9cfcae8325269e6bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f62">Query::op</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#04dd86610a63fd3b3ee6f3795acad331">get_default_op</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the default boolean operator.  <a href="#04dd86610a63fd3b3ee6f3795acad331"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#b117738d9b9eb9a09070b8b3b3305a31">set_database</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the database being searched.  <a href="#b117738d9b9eb9a09070b8b3b3305a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#2e59a4aee8ae3288e0053ce5c9625ead">parse_query</a> (const std::string &amp;query_string, unsigned flags=FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE, const std::string &amp;default_prefix=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a query.  <a href="#2e59a4aee8ae3288e0053ce5c9625ead"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#dfd545b4ac739adc2e4171169a500f33">add_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a probabilistic term prefix.  <a href="#dfd545b4ac739adc2e4171169a500f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ac4192166cf335462bbfa8f1f17a667c">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#ac4192166cf335462bbfa8f1f17a667c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#bbf9c22f3d6dd105353bd80604958c05">stoplist_begin</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over terms omitted from the query as stopwords.  <a href="#bbf9c22f3d6dd105353bd80604958c05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12f8b35d53f03b60579458c3f0b89168"></a><!-- doxytag: member="Xapian::QueryParser::stoplist_end" ref="12f8b35d53f03b60579458c3f0b89168" args="() const" -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>stoplist_end</b> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#bed4668a2ed42741c3c0cfc7eb7db2d8">unstem_begin</a> (const std::string &amp;term) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over unstemmed forms of the given (stemmed) term used in the query.  <a href="#bed4668a2ed42741c3c0cfc7eb7db2d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8e87bfa487e8bcae38500da131368aa3"></a><!-- doxytag: member="Xapian::QueryParser::unstem_end" ref="8e87bfa487e8bcae38500da131368aa3" args="(const std::string &amp;) const" -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>unstem_end</b> (const std::string &amp;) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#fc2a7311515552e0834f608c7d28debf">add_valuerangeprocessor</a> (<a class="el" href="structXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *vrproc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a <a class="el" href="structXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors.">ValueRangeProcessor</a>.  <a href="#fc2a7311515552e0834f608c7d28debf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#1dad5bb9c034ddc02959f28d5bbb7e2b">get_corrected_query_string</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the spelling-corrected query string.  <a href="#1dad5bb9c034ddc02959f28d5bbb7e2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#1fe3eb188c4f4d9b9fb420918b0548e6">get_description</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing this object.  <a href="#1fe3eb188c4f4d9b9fb420918b0548e6"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string. 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e4"></a><!-- doxytag: member="Xapian::QueryParser::feature_flag" ref="fdaec563f70612cc1c6939226ebdb1e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1QueryParser.html#fdaec563f70612cc1c6939226ebdb1e4">Xapian::QueryParser::feature_flag</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum of feature flags. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e459f19295c3150ad8511b7e8457fef73b"></a><!-- doxytag: member="FLAG_BOOLEAN" ref="fdaec563f70612cc1c6939226ebdb1e459f19295c3150ad8511b7e8457fef73b" args="" -->FLAG_BOOLEAN</em>&nbsp;</td><td>
Support AND, OR, etc and bracketed subexpressions. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e49e741302592d96033bd31bcdae63a044"></a><!-- doxytag: member="FLAG_PHRASE" ref="fdaec563f70612cc1c6939226ebdb1e49e741302592d96033bd31bcdae63a044" args="" -->FLAG_PHRASE</em>&nbsp;</td><td>
Support quoted phrases. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e4b20af685e8582c7a13a51aaf313aa326"></a><!-- doxytag: member="FLAG_LOVEHATE" ref="fdaec563f70612cc1c6939226ebdb1e4b20af685e8582c7a13a51aaf313aa326" args="" -->FLAG_LOVEHATE</em>&nbsp;</td><td>
Support + and -. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e442e07cee2f367b773187cc4fe73ab7fc"></a><!-- doxytag: member="FLAG_BOOLEAN_ANY_CASE" ref="fdaec563f70612cc1c6939226ebdb1e442e07cee2f367b773187cc4fe73ab7fc" args="" -->FLAG_BOOLEAN_ANY_CASE</em>&nbsp;</td><td>
Support AND, OR, etc even if they aren't in ALLCAPS. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e4e903f7f74be4432120446cca7fd22396"></a><!-- doxytag: member="FLAG_WILDCARD" ref="fdaec563f70612cc1c6939226ebdb1e4e903f7f74be4432120446cca7fd22396" args="" -->FLAG_WILDCARD</em>&nbsp;</td><td>
Support right truncation (e.g. 
<p>
Xap*).<p>
NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling set_database. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e484cf1fd3c0289633db308d687bed8cf2"></a><!-- doxytag: member="FLAG_PURE_NOT" ref="fdaec563f70612cc1c6939226ebdb1e484cf1fd3c0289633db308d687bed8cf2" args="" -->FLAG_PURE_NOT</em>&nbsp;</td><td>
Allow queries such as 'NOT apples'. 
<p>
These require the use of a list of all documents in the database which is potentially expensive, so this feature isn't enabled by default. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e439a9ed1d92a1a1bd5bcd66e721918661"></a><!-- doxytag: member="FLAG_PARTIAL" ref="fdaec563f70612cc1c6939226ebdb1e439a9ed1d92a1a1bd5bcd66e721918661" args="" -->FLAG_PARTIAL</em>&nbsp;</td><td>
Enable partial matching. 
<p>
Partial matching causes the parser to treat the query as a "partially entered" search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.<p>
NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling set_database. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e47bb7341fb84b787be2572e3379997b33"></a><!-- doxytag: member="FLAG_SPELLING_CORRECTION" ref="fdaec563f70612cc1c6939226ebdb1e47bb7341fb84b787be2572e3379997b33" args="" -->FLAG_SPELLING_CORRECTION</em>&nbsp;</td><td>
Enable spelling correction. 
<p>
For each word in the query which doesn't exist as a term in the database, <a class="el" href="classXapian_1_1Database.html#5d9704bce82dffecdf7434d57dccdcfa" title="Suggest a spelling correction.">Database::get_spelling_suggestion()</a> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <a class="el" href="classXapian_1_1QueryParser.html#1dad5bb9c034ddc02959f28d5bbb7e2b" title="Get the spelling-corrected query string.">QueryParser::get_corrected_query_string()</a>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <a class="el" href="classXapian_1_1QueryParser.html#2e59a4aee8ae3288e0053ce5c9625ead" title="Parse a query.">QueryParser::parse_query()</a> again.<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#b117738d9b9eb9a09070b8b3b3305a31" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e400722e941bf07543aa9e7374fb9213ec"></a><!-- doxytag: member="FLAG_SYNONYM" ref="fdaec563f70612cc1c6939226ebdb1e400722e941bf07543aa9e7374fb9213ec" args="" -->FLAG_SYNONYM</em>&nbsp;</td><td>
Enable synonym operator '~'. 
<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#b117738d9b9eb9a09070b8b3b3305a31" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e40a17e810397100d7bcca858ccc0d7f08"></a><!-- doxytag: member="FLAG_AUTO_SYNONYMS" ref="fdaec563f70612cc1c6939226ebdb1e40a17e810397100d7bcca858ccc0d7f08" args="" -->FLAG_AUTO_SYNONYMS</em>&nbsp;</td><td>
Enable automatic use of synonyms for single terms. 
<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#b117738d9b9eb9a09070b8b3b3305a31" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e4abb8af23bce169ef29b66f33b4e38acc"></a><!-- doxytag: member="FLAG_AUTO_MULTIWORD_SYNONYMS" ref="fdaec563f70612cc1c6939226ebdb1e4abb8af23bce169ef29b66f33b4e38acc" args="" -->FLAG_AUTO_MULTIWORD_SYNONYMS</em>&nbsp;</td><td>
Enable automatic use of synonyms for single terms and groups of terms. 
<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#b117738d9b9eb9a09070b8b3b3305a31" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fdaec563f70612cc1c6939226ebdb1e48d441f43bfaf080cabccc437726e0bb0"></a><!-- doxytag: member="FLAG_DEFAULT" ref="fdaec563f70612cc1c6939226ebdb1e48d441f43bfaf080cabccc437726e0bb0" args="" -->FLAG_DEFAULT</em>&nbsp;</td><td>
The default flags. 
<p>
Used if you don't explicitly pass any to <em><a class="el" href="classXapian_1_1QueryParser.html#2e59a4aee8ae3288e0053ce5c9625ead" title="Parse a query.">parse_query()</a></em>.<p>
Added in <a class="el" href="namespaceXapian.html" title="The Xapian library lives in the Xapian namespace.">Xapian</a> 1.0.11. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b5bd2f39ee1d3ed110876ca4777e74f0"></a><!-- doxytag: member="Xapian::QueryParser::QueryParser" ref="b5bd2f39ee1d3ed110876ca4777e74f0" args="(const QueryParser &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::QueryParser::QueryParser           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="839b417cc7fd1068a19f2e346945d613"></a><!-- doxytag: member="Xapian::QueryParser::QueryParser" ref="839b417cc7fd1068a19f2e346945d613" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::QueryParser::QueryParser           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="0a651bc6a41a13c1a7ef0fccbb0b0865"></a><!-- doxytag: member="Xapian::QueryParser::~QueryParser" ref="0a651bc6a41a13c1a7ef0fccbb0b0865" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::QueryParser::~QueryParser           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="20b23a728f0eb8532af052628c6c037a"></a><!-- doxytag: member="Xapian::QueryParser::operator=" ref="20b23a728f0eb8532af052628c6c037a" args="(const QueryParser &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a>&amp; Xapian::QueryParser::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment. 
<p>

</div>
</div><p>
<a class="anchor" name="d0529560adaf114192aa2d4a8055ddc1"></a><!-- doxytag: member="Xapian::QueryParser::set_stemmer" ref="d0529560adaf114192aa2d4a8055ddc1" args="(const Xapian::Stem &amp;stemmer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemmer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stemmer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stemmer. 
<p>
This sets the stemming algorithm which will be used by the query parser. Note that the stemming algorithm will only be used according to the stemming strategy set by <a class="el" href="classXapian_1_1QueryParser.html#4829638f027160d317e35740c3ae2b31" title="Set the stemming strategy.">set_stemming_strategy()</a>, which defaults to STEM_NONE. Therefore, to use a stemming algorithm, you will also need to call <a class="el" href="classXapian_1_1QueryParser.html#4829638f027160d317e35740c3ae2b31" title="Set the stemming strategy.">set_stemming_strategy()</a> with a value other than STEM_NONE. 
</div>
</div><p>
<a class="anchor" name="4829638f027160d317e35740c3ae2b31"></a><!-- doxytag: member="Xapian::QueryParser::set_stemming_strategy" ref="4829638f027160d317e35740c3ae2b31" args="(stem_strategy strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemming_strategy           </td>
          <td>(</td>
          <td class="paramtype">stem_strategy&nbsp;</td>
          <td class="paramname"> <em>strategy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stemming strategy. 
<p>
This controls how the query parser will apply the stemming algorithm. The default value is STEM_NONE. The possible values are:<p>
<ul>
<li>STEM_NONE: Don't perform any stemming.</li><li>STEM_SOME: Search for stemmed forms of terms except for those which start with a capital letter, or are followed by certain characters (currently: (/@&lt;&gt;=*[{" ), or are used with operators which need positional information. Stemmed terms are prefixed with 'Z'.</li><li>STEM_ALL: Search for stemmed forms of all words (note: no 'Z' prefix is added).</li></ul>
<p>
Note that the stemming algorithm is only applied to words in probabilistic fields - boolean filter terms are never stemmed. 
</div>
</div><p>
<a class="anchor" name="fa2cd85108b18ee5f01c43abb6833f67"></a><!-- doxytag: member="Xapian::QueryParser::set_stopper" ref="fa2cd85108b18ee5f01c43abb6833f67" args="(const Stopper *stop=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stopper           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *&nbsp;</td>
          <td class="paramname"> <em>stop</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stopper. 
<p>

</div>
</div><p>
<a class="anchor" name="7c7492787fcdd3e9cfcae8325269e6bd"></a><!-- doxytag: member="Xapian::QueryParser::set_default_op" ref="7c7492787fcdd3e9cfcae8325269e6bd" args="(Query::op default_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_default_op           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f62">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>default_op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default boolean operator. 
<p>

</div>
</div><p>
<a class="anchor" name="04dd86610a63fd3b3ee6f3795acad331"></a><!-- doxytag: member="Xapian::QueryParser::get_default_op" ref="04dd86610a63fd3b3ee6f3795acad331" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f62">Query::op</a> Xapian::QueryParser::get_default_op           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the default boolean operator. 
<p>

</div>
</div><p>
<a class="anchor" name="b117738d9b9eb9a09070b8b3b3305a31"></a><!-- doxytag: member="Xapian::QueryParser::set_database" ref="b117738d9b9eb9a09070b8b3b3305a31" args="(const Database &amp;db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_database           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the database being searched. 
<p>

</div>
</div><p>
<a class="anchor" name="2e59a4aee8ae3288e0053ce5c9625ead"></a><!-- doxytag: member="Xapian::QueryParser::parse_query" ref="2e59a4aee8ae3288e0053ce5c9625ead" args="(const std::string &amp;query_string, unsigned flags=FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE, const std::string &amp;default_prefix=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::QueryParser::parse_query           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>query_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>default_prefix</em> = <code>&quot;&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a query. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query_string</em>&nbsp;</td><td>A free-text query as entered by a user </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Zero or more Query::feature_flag specifying what features the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_prefix</em>&nbsp;</td><td>The default term prefix to use (default none). For example, you can pass "A" when parsing an "Author" field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dfd545b4ac739adc2e4171169a500f33"></a><!-- doxytag: member="Xapian::QueryParser::add_prefix" ref="dfd545b4ac739adc2e4171169a500f33" args="(const std::string &amp;field, const std::string &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_prefix           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a probabilistic term prefix. 
<p>
For example:<p>
<div class="fragment"><pre class="fragment">  qp.add_prefix(<span class="stringliteral">"author"</span>, <span class="stringliteral">"A"</span>);
</pre></div><p>
This allows the user to search for author:Orwell which will be converted to a search for the term "Aorwell".<p>
Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.<p>
As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f6282e33801d897b974065a281e1c34e39d" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a></code>.<p>
If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used as the default prefix. If you do this and also specify the <code>default_prefix</code> parameter to <code><a class="el" href="classXapian_1_1QueryParser.html#2e59a4aee8ae3288e0053ce5c9625ead" title="Parse a query.">parse_query()</a></code>, then the <code>default_prefix</code> parameter will override.<p>
If you call <code><a class="el" href="classXapian_1_1QueryParser.html#dfd545b4ac739adc2e4171169a500f33" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#ac4192166cf335462bbfa8f1f17a667c" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code>Xapian::InvalidOperationError</code> exception will be thrown.<p>
In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>The user visible field name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The term prefix to map this to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac4192166cf335462bbfa8f1f17a667c"></a><!-- doxytag: member="Xapian::QueryParser::add_boolean_prefix" ref="ac4192166cf335462bbfa8f1f17a667c" args="(const std::string &amp;field, const std::string &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. 
<p>
For example:<p>
<div class="fragment"><pre class="fragment">  qp.add_boolean_prefix(<span class="stringliteral">"site"</span>, <span class="stringliteral">"H"</span>);
</pre></div><p>
This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any probabilistic query with <code><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f622140c62093d4a2ecacee2fd69f70b17e" title="As AND, but use only weights from left subquery.">Xapian::Query::OP_FILTER</a></code>.<p>
If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <code><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f6282e33801d897b974065a281e1c34e39d" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a></code> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <code><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f6219fe995e29748a4324108b2f859f8607" title="Return iff both subqueries are satisfied.">Xapian::Query::OP_AND</a></code> operator.<p>
Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.<p>
For example, if "site" and "domain" map to "H", but author maps to "A", a search for "site:foo domain:bar author:Fred" will map to "(Hfoo OR Hbar) AND Afred".<p>
As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code><a class="el" href="classXapian_1_1Query.html#df6014fe7725e5427be7210771919f6282e33801d897b974065a281e1c34e39d" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a></code>.<p>
Calling this method with an empty string for <em>field</em> will cause a <code>Xapian::InvalidArgumentError</code>.<p>
If you call <code><a class="el" href="classXapian_1_1QueryParser.html#dfd545b4ac739adc2e4171169a500f33" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#ac4192166cf335462bbfa8f1f17a667c" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code>Xapian::InvalidOperationError</code> exception will be thrown.<p>
In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>The user visible field name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The term prefix to map this to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bbf9c22f3d6dd105353bd80604958c05"></a><!-- doxytag: member="Xapian::QueryParser::stoplist_begin" ref="bbf9c22f3d6dd105353bd80604958c05" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::QueryParser::stoplist_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate over terms omitted from the query as stopwords. 
<p>

</div>
</div><p>
<a class="anchor" name="bed4668a2ed42741c3c0cfc7eb7db2d8"></a><!-- doxytag: member="Xapian::QueryParser::unstem_begin" ref="bed4668a2ed42741c3c0cfc7eb7db2d8" args="(const std::string &amp;term) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::QueryParser::unstem_begin           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>term</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterate over unstemmed forms of the given (stemmed) term used in the query. 
<p>

</div>
</div><p>
<a class="anchor" name="fc2a7311515552e0834f608c7d28debf"></a><!-- doxytag: member="Xapian::QueryParser::add_valuerangeprocessor" ref="fc2a7311515552e0834f608c7d28debf" args="(Xapian::ValueRangeProcessor *vrproc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_valuerangeprocessor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *&nbsp;</td>
          <td class="paramname"> <em>vrproc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a <a class="el" href="structXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors.">ValueRangeProcessor</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="1dad5bb9c034ddc02959f28d5bbb7e2b"></a><!-- doxytag: member="Xapian::QueryParser::get_corrected_query_string" ref="1dad5bb9c034ddc02959f28d5bbb7e2b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::QueryParser::get_corrected_query_string           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the spelling-corrected query string. 
<p>
This will only be set if FLAG_SPELLING_CORRECTION is specified when <a class="el" href="classXapian_1_1QueryParser.html#2e59a4aee8ae3288e0053ce5c9625ead" title="Parse a query.">QueryParser::parse_query()</a> was last called.<p>
If there were no corrections, an empty string is returned. 
</div>
</div><p>
<a class="anchor" name="1fe3eb188c4f4d9b9fb420918b0548e6"></a><!-- doxytag: member="Xapian::QueryParser::get_description" ref="1fe3eb188c4f4d9b9fb420918b0548e6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::QueryParser::get_description           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string describing this object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>include/xapian/<a class="el" href="queryparser_8h-source.html">queryparser.h</a></ul>
<hr>
<address><small>
Documentation for Xapian (version 1.0.11).<br>
Generated on 15 Mar 2009 by
<a href="http://www.doxygen.org/">Doxygen 1.5.2</a>.
</small></address>
</body>
</html>
